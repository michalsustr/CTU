<?xml version="1.0" encoding="utf-8"?><!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_1.dtd'><nta><declaration>/*
##########
# Zadání #
##########

Vlastnosti nádraží
==================
1) Každý uzel s více než jednou výstupní hranou je zároveň výhybka.
2) Časově variabilní prvky v nádraží jsou:
   - pohybující se vlaky,
   - na vstupních uzlech řízená návěstidla a
   - výhybky.
3) V daném časovém okamžiku je každý vlak právě v jednom uzlu.
4) Vlaky se pohybují pouze ve směru orientace hran grafu (tj. nemohou couvat).
5) Je-li v uzlu vlak, platí, že vlak někdy do uzlu přijel (nebyl tam od nepaměti) a jednou odjede (ale není určeno, kdy, je to na “rozhodnutí strojvedoucího”).
6) Na vjezdových uzlech (a pouze tam) jsou návěstidla. Ta blokují odjezd vlaků ze vstupních uzlů: Je-li návěstidlo zavřené, vlak zůstává na vstupním uzlu; je-li otevřené, může (ale nemusí) vyjet. Vlak (strojvedoucí) vždy tato návěstidla respektuje. Každý vjezdový uzel má právě jednu výstupní hranu, není tedy nikdy výhybkou.
7) Každý vlak má dán výstupní uzel, do kterého chce dojet. Tento cíl se nemění celou dobu, co vlak projíždí nádražím.
8) Nádraží podle tohoto cíle směruje vlak pomocí přepínání výhybek. Řídící systém nádraží může libovolně nastavovat stav výhybek.
9) Pokud je vjezdový uzel prázdný, může se v něm kdykoliv objevit nový přijíždějící vlak (i hned po odjezdu předcházejícího).


Kritické stavy v nádraží
========================
V nádraží rozlišujeme tyto kritické stavy:

1) Vlak stojí v uzlu (který je zároveň výhybkou, viz výše), a dojde k přepnutí výhybky.
2) Dva nebo více vlaků přijede do stejného uzlu.
3) Vstupní návěstidlo zůstane trvale uzavřené.

Úkoly
=====
Navrhněte program, který:

1) pro zadané nádraží navrhne řídící systém a zformalizuje podle uvedeného zadání;
2) dokáže, že navržený řídící systém pracuje správně, tj. že se nádraží nemůže dostat do kritického stavu.

Výsledek práce shrňte v (stačí krátké) technické zprávě, kde bude popsán zvolený postup, a zejména podrobně rozebrané dosažené výsledky.

*/

//
// &lt;GENERATED_A&gt;
//
const int PATHS_CNT = 6; // number of ways how you can get from IN to OUT for given instance of problem
const int NODE_CNT = 9;  // number of nodes (for given instance of problem)
const int MAX_PATH_LENGTH = 5; // maximum length of a train path - aligned by the longest path and +1
//
// &lt;/GENERATED_A&gt;
//

// Train states
chan pending[PATHS_CNT];  // Waiting to arrive to station, it has been generated by TrainGenerator
bool start[PATHS_CNT];    // Train is waiting at the IN station, it is stopped by the gate until the gate is opened
bool going[PATHS_CNT];    // Train is on the way to the OUT node
chan advance[PATHS_CNT];  // Train is signalled to advance by TrainWill

// Inputs
bool free[NODE_CNT]; // IN is not occupied by train, 
broadcast chan open[NODE_CNT]; // IN gate is opened, more trains can receive this message

// Nodes

// All nodes are treated as switches, also nodes that have only one rail.
// To make sure that the train doesn't "create" a path there is a field conn_allowed
// that serves as a guard for these situations.
bool conn[NODE_CNT][NODE_CNT]; 
chan switched[NODE_CNT]; // Signal to node that it has been switched
chan enter[NODE_CNT];    // Signal to node that train is entering
chan leave[NODE_CNT];	 // Signal to node that train is leaving

// Errors
chan internal_error, critical;


//
//&lt;GENERATED_B&gt;
//
const int paths[PATHS_CNT][MAX_PATH_LENGTH] = {
	{0, 1, 2, -1, -1},
	{0, 1, 3, 6, -1},
	{4, 5, 3, 2, -1},
	{4, 5, 3, 6, -1},
	{7, 8, 3, 2, -1},
	{7, 8, 6, -1, -1}
};
// 
// &lt;/GENERATED_B&gt;
//


void initialize() {
	for(i : int[0,NODE_CNT-1]) {
		for(j : int[0,NODE_CNT-1]) {
			conn[i][j] = false;
		}
	}

	for(i : int[0,PATHS_CNT-1]) {
		free[paths[i][0]] = true;
		start[i] = false;
		going[i] = false;
	}
}


</declaration><template><name x="5" y="5">Train</name><parameter>chan &amp;pending, bool &amp;start, bool &amp;going,   chan &amp;advance,   broadcast chan &amp;open,   bool &amp;free,  bool &amp;conn[NODE_CNT][NODE_CNT],  chan &amp;switched[NODE_CNT], chan &amp;enter[NODE_CNT], chan &amp;leave[NODE_CNT],   chan &amp;internal_error, int path_idx, const int &amp;path[MAX_PATH_LENGTH]</parameter><declaration>// Signal via free variable that new train can be generated
// Do this only when the train is leaving the IN station (the first node on its path)
void update_free(int path_idx, bool &amp;free) {
	if(path_idx==0) free=true;
}

void update_switch(int from, int to) {
	if(to == -1) return;

	for(i : int[0,NODE_CNT-1]) {
		conn[from][i] = false;
	}
	conn[from][to] = true;
}</declaration><location id="id0" x="-200" y="-40"><committed/></location><location id="id1" x="-8" y="96"><name x="-24" y="64">END</name><committed/></location><location id="id2" x="1000" y="-40"><name x="944" y="-96">WAIT_FOR_ADVANCE</name></location><location id="id3" x="312" y="-40"><name x="240" y="-80">CONTINUE_OR_END</name><committed/></location><location id="id4" x="800" y="-40"><committed/></location><location id="id5" x="584" y="-40"><committed/></location><location id="id6" x="112" y="-40"><name x="72" y="-112">WAITING_FOR_LAZY_DRIVER_WITH_GATE_OPENED</name></location><location id="id7" x="1224" y="-40" color="#ff0000"><name x="1240" y="-48">INTERNAL_ERROR</name></location><location id="id8" x="-32" y="-40"><name x="-40" y="-24">IN</name></location><location id="id9" x="-344" y="-40"><name x="-416" y="-48">START</name></location><init ref="id9"/><transition><source ref="id2"/><target ref="id2"/><nail x="984" y="-72"/><nail x="1024" y="-72"/></transition><transition><source ref="id9"/><target ref="id9"/><nail x="-360" y="-72"/><nail x="-320" y="-72"/></transition><transition><source ref="id0"/><target ref="id8"/><label kind="synchronisation" x="-168" y="-32">enter[path[0]]!</label></transition><transition><source ref="id1"/><target ref="id9"/><nail x="-344" y="96"/></transition><transition><source ref="id3"/><target ref="id1"/><label kind="guard" x="-96" y="113">path[path_idx+2] == -1</label><label kind="synchronisation" x="-96" y="136">leave[path[path_idx]]!</label><label kind="assignment" x="-96" y="160">going=false</label><nail x="280" y="96"/></transition><transition><source ref="id2"/><target ref="id3"/><label kind="guard" x="584" y="112">conn
  [path[path_idx]]
  [path[path_idx+1]]</label><label kind="synchronisation" x="584" y="160">advance?</label><nail x="1000" y="96"/><nail x="344" y="96"/></transition><transition><source ref="id6"/><target ref="id3"/><label kind="synchronisation" x="176" y="-32">advance?</label></transition><transition><source ref="id5"/><target ref="id4"/><label kind="synchronisation" x="600" y="-24">leave[path[path_idx]]!</label><label kind="assignment" x="600" y="0">update_free(path_idx, free)</label></transition><transition><source ref="id3"/><target ref="id5"/><label kind="guard" x="336" y="-32">path[path_idx+2] != -1</label><label kind="synchronisation" x="352" y="64">switched[path[path_idx+1]]!</label><label kind="assignment" x="344" y="8">update_switch(
  path[path_idx+1], 
  path[path_idx+2]
)</label></transition><transition><source ref="id8"/><target ref="id6"/><label kind="synchronisation" x="0" y="-32">open?</label><label kind="assignment" x="0" y="-8">start=false,
going=true,
path_idx = 0</label></transition><transition><source ref="id8"/><target ref="id8"/><nail x="8" y="-112"/><nail x="-72" y="-112"/></transition><transition><source ref="id2"/><target ref="id7"/><label kind="guard" x="1048" y="-24">!conn
  [path[path_idx]]
  [path[path_idx+1]]</label><label kind="synchronisation" x="1056" y="24">internal_error!</label></transition><transition><source ref="id4"/><target ref="id2"/><label kind="synchronisation" x="808" y="-24">enter[path[path_idx+1]]!</label><label kind="assignment" x="896" y="0">path_idx++</label></transition><transition><source ref="id9"/><target ref="id0"/><label kind="synchronisation" x="-304" y="-32">pending?</label><label kind="assignment" x="-312" y="-8">start = true,
free = false</label></transition></template><template><name>TrainWill</name><parameter>chan &amp;advance, bool &amp;going</parameter><location id="id10" x="0" y="0"><name x="24" y="-8">IS_GOING</name></location><init ref="id10"/><transition><source ref="id10"/><target ref="id10"/><label kind="guard" x="-112" y="24">!going</label><nail x="-56" y="64"/><nail x="56" y="64"/></transition><transition><source ref="id10"/><target ref="id10"/><label kind="guard" x="-112" y="-48">going</label><label kind="synchronisation" x="64" y="-48">advance!</label><nail x="-56" y="-72"/><nail x="56" y="-72"/></transition></template><template><name>TrainGenerator</name><parameter>bool &amp;free, chan &amp;pending</parameter><location id="id11" x="160" y="-8"><name x="184" y="-16">IS_GENERATING</name></location><init ref="id11"/><transition><source ref="id11"/><target ref="id11"/><label kind="guard" x="72" y="32">!free</label><nail x="192" y="80"/><nail x="120" y="80"/></transition><transition><source ref="id11"/><target ref="id11"/><label kind="guard" x="72" y="-64">free</label><label kind="synchronisation" x="216" y="-80">pending!</label><label kind="assignment" x="216" y="-48">free=false</label><nail x="200" y="-96"/><nail x="112" y="-96"/></transition></template><template><name>Node</name><parameter>chan &amp;enter, chan &amp;leave, chan &amp;switched, chan &amp;critical, chan &amp;internal_error </parameter><location id="id12" x="192" y="0"><committed/></location><location id="id13" x="-208" y="0"><committed/></location><location id="id14" x="-368" y="0" color="#ff0000"><name x="-512" y="-8">INTERNAL_ERROR</name></location><location id="id15" x="304" y="0" color="#ff0000"><name x="320" y="-8">CRITICAL</name></location><location id="id16" x="56" y="0"><name x="48" y="-56">OCCUPIED</name></location><location id="id17" x="-96" y="0"><name x="-120" y="-48">EMPTY</name></location><init ref="id17"/><transition><source ref="id17"/><target ref="id17"/><label kind="synchronisation" x="-184" y="72">switched?</label><nail x="-160" y="24"/><nail x="-168" y="64"/><nail x="-128" y="64"/><nail x="-128" y="32"/></transition><transition><source ref="id14"/><target ref="id14"/><nail x="-384" y="-32"/><nail x="-360" y="-32"/></transition><transition><source ref="id15"/><target ref="id15"/><nail x="296" y="-32"/><nail x="320" y="-32"/></transition><transition><source ref="id16"/><target ref="id16"/><nail x="48" y="-32"/><nail x="80" y="-32"/></transition><transition><source ref="id17"/><target ref="id17"/><nail x="-112" y="64"/><nail x="-80" y="64"/></transition><transition><source ref="id12"/><target ref="id15"/><label kind="synchronisation" x="224" y="-16">critical!</label></transition><transition><source ref="id13"/><target ref="id14"/><label kind="synchronisation" x="-336" y="-24">internal_error!</label></transition><transition><source ref="id16"/><target ref="id12"/><label kind="synchronisation" x="88" y="32">switched?</label><nail x="80" y="24"/><nail x="160" y="24"/></transition><transition><source ref="id17"/><target ref="id13"/><label kind="synchronisation" x="-168" y="-24">leave?</label></transition><transition><source ref="id16"/><target ref="id12"/><label kind="synchronisation" x="96" y="-24">enter?</label></transition><transition><source ref="id16"/><target ref="id17"/><label kind="synchronisation" x="-32" y="32">leave?</label><nail x="32" y="24"/><nail x="-64" y="24"/></transition><transition><source ref="id17"/><target ref="id16"/><label kind="synchronisation" x="-40" y="-48">enter?</label><nail x="-72" y="-24"/><nail x="32" y="-24"/></transition></template><template><name>ControlSystem</name><parameter>broadcast chan &amp;open[NODE_CNT]</parameter><declaration>bool open_condition(int in) {
//
// &lt;GENERATED_C&gt;
//
	if(in == 0)
		return ((start[0]  &amp;&amp; !going[0] &amp;&amp; !going[1] &amp;&amp; !going[2] &amp;&amp; !going[3] &amp;&amp; !going[4] &amp;&amp; !going[5])
		     || (start[0] &amp;&amp; !going[0] &amp;&amp; !going[1] &amp;&amp; !going[2] &amp;&amp; going[3] &amp;&amp; !going[4] &amp;&amp; !going[5])
		     || (start[0] &amp;&amp; !going[0] &amp;&amp; !going[1] &amp;&amp; !going[2] &amp;&amp; !going[3] &amp;&amp; !going[4] &amp;&amp; going[5])
		     || (start[1]  &amp;&amp; !going[0] &amp;&amp; !going[1] &amp;&amp; !going[2] &amp;&amp; !going[3] &amp;&amp; !going[4] &amp;&amp; !going[5]));
	if(in == 4)
		return ((start[2]  &amp;&amp; !going[0] &amp;&amp; !going[1] &amp;&amp; !going[2] &amp;&amp; !going[3] &amp;&amp; !going[4] &amp;&amp; !going[5])
		     || (start[2] &amp;&amp; !going[0] &amp;&amp; !going[1] &amp;&amp; !going[2] &amp;&amp; !going[3] &amp;&amp; !going[4] &amp;&amp; going[5])
		     || (start[3]  &amp;&amp; !going[0] &amp;&amp; !going[1] &amp;&amp; !going[2] &amp;&amp; !going[3] &amp;&amp; !going[4] &amp;&amp; !going[5])
		     || (start[3] &amp;&amp; going[0] &amp;&amp; !going[1] &amp;&amp; !going[2] &amp;&amp; !going[3] &amp;&amp; !going[4] &amp;&amp; !going[5]));
	if(in == 7)
		return ((start[4]  &amp;&amp; !going[0] &amp;&amp; !going[1] &amp;&amp; !going[2] &amp;&amp; !going[3] &amp;&amp; !going[4] &amp;&amp; !going[5])
		     || (start[5]  &amp;&amp; !going[0] &amp;&amp; !going[1] &amp;&amp; !going[2] &amp;&amp; !going[3] &amp;&amp; !going[4] &amp;&amp; !going[5])
		     || (start[5] &amp;&amp; going[0] &amp;&amp; !going[1] &amp;&amp; !going[2] &amp;&amp; !going[3] &amp;&amp; !going[4] &amp;&amp; !going[5])
		     || (start[5] &amp;&amp; !going[0] &amp;&amp; !going[1] &amp;&amp; going[2] &amp;&amp; !going[3] &amp;&amp; !going[4] &amp;&amp; !going[5]));
//
// &lt;/GENERATED_C&gt;
//

    return false;
}

</declaration><location id="id18" x="-816" y="-8"><name x="-826" y="-38">INIT</name></location><location id="id19" x="-680" y="-8"><name x="-696" y="-40">OPEN</name></location><init ref="id18"/><transition><source ref="id18"/><target ref="id19"/><label kind="assignment" x="-776" y="0">initialize()</label></transition><transition><source ref="id19"/><target ref="id19"/><label kind="select" x="-528" y="-48">i : int[0, NODE_CNT-1]</label><label kind="guard" x="-528" y="-24">open_condition(i)</label><label kind="synchronisation" x="-740" y="-23">open[i]!</label><nail x="-536" y="-64"/><nail x="-536" y="48"/></transition></template><template><name>Errors</name><parameter>chan &amp;critical, chan &amp;internal_error</parameter><location id="id20" x="104" y="0" color="#ff0000"><name x="128" y="-8">ERROR</name></location><location id="id21" x="-16" y="0"><name x="-56" y="-8">OK</name></location><init ref="id21"/><transition><source ref="id20"/><target ref="id20"/><nail x="96" y="-24"/><nail x="128" y="-24"/></transition><transition><source ref="id21"/><target ref="id21"/><nail x="-32" y="-24"/><nail x="0" y="-24"/></transition><transition><source ref="id21"/><target ref="id20"/><label kind="synchronisation" x="-8" y="40">internal_error?</label><nail x="16" y="32"/><nail x="72" y="32"/></transition><transition><source ref="id21"/><target ref="id20"/><label kind="synchronisation" x="16" y="-32">critical?</label></transition></template><system>//
// &lt;GENERATED_D&gt;
//
n0=Node(enter[0], leave[0], switched[0], critical, internal_error);
n1=Node(enter[1], leave[1], switched[1], critical, internal_error);
n2=Node(enter[2], leave[2], switched[2], critical, internal_error);
n3=Node(enter[3], leave[3], switched[3], critical, internal_error);
n4=Node(enter[4], leave[4], switched[4], critical, internal_error);
n5=Node(enter[5], leave[5], switched[5], critical, internal_error);
n6=Node(enter[6], leave[6], switched[6], critical, internal_error);
n7=Node(enter[7], leave[7], switched[7], critical, internal_error);
n8=Node(enter[8], leave[8], switched[8], critical, internal_error);

train0=Train(
	pending[0],start[0],going[0], advance[0], open[0],  free[0], 
	conn, switched,  enter,  leave,  internal_error, 
	0, paths[0]);
trainWill0=TrainWill(advance[0], going[0]);
trainGenerator0=TrainGenerator(free[0], pending[0]);

train1=Train(
	pending[1],start[1],going[1], advance[1], open[0],  free[0], 
	conn, switched,  enter,  leave,  internal_error, 
	0, paths[1]);
trainWill1=TrainWill(advance[1], going[1]);
trainGenerator1=TrainGenerator(free[0], pending[1]);

train2=Train(
	pending[2],start[2],going[2], advance[2], open[4],  free[4], 
	conn, switched,  enter,  leave,  internal_error, 
	0, paths[2]);
trainWill2=TrainWill(advance[2], going[2]);
trainGenerator2=TrainGenerator(free[4], pending[2]);

train3=Train(
	pending[3],start[3],going[3], advance[3], open[4],  free[4], 
	conn, switched,  enter,  leave,  internal_error, 
	0, paths[3]);
trainWill3=TrainWill(advance[3], going[3]);
trainGenerator3=TrainGenerator(free[4], pending[3]);

train4=Train(
	pending[4],start[4],going[4], advance[4], open[7],  free[7], 
	conn, switched,  enter,  leave,  internal_error, 
	0, paths[4]);
trainWill4=TrainWill(advance[4], going[4]);
trainGenerator4=TrainGenerator(free[7], pending[4]);

train5=Train(
	pending[5],start[5],going[5], advance[5], open[7],  free[7], 
	conn, switched,  enter,  leave,  internal_error, 
	0, paths[5]);
trainWill5=TrainWill(advance[5], going[5]);
trainGenerator5=TrainGenerator(free[7], pending[5]);

cs=ControlSystem(open);
err=Errors(critical,internal_error);
system cs,err,
	n0,n1,n2,n3,n4,n5,n6,n7,n8,
	train0, trainWill0, trainGenerator0,
	train1, trainWill1, trainGenerator1,
	train2, trainWill2, trainGenerator2,
	train3, trainWill3, trainGenerator3,
	train4, trainWill4, trainGenerator4,
	train5, trainWill5, trainGenerator5
;
//
// &lt;/GENERATED_D&gt;
//</system></nta>
